---
title: 데코레이터
description:
categories:
 - nestjs
tags:
---

# 데코레이터

## 데코레이터란?
Nest는 데코레이터를 적극 활용합니다. 데코레이터를 잘 사용하면 횡단관심사를 분리하여 관점 지향 프로그래밍을 적용한 코드를 작성할 수 있습니다. 타입스크립트의 데코레이터는 파이썬의 데코레이터나 **자바의 어노테이션**과 유사한 기능을 합니다. **클래스, 메서드, 접근자, 프로퍼티, 매개변수**에 적용 가능합니다. 각 요소의 선언부 앞에 @로 시작하는 데코레이터를 선언하면 데코레이터로 구현된 코드를 함께 실행합니다. 예를 들어 다음코드는 유저 생성 요청의 본문을 DTO로 표현한 클래스입니다.

```typescript
class CreateUserDto {
  @IsEmail()
  @MaxLength(60)
  readonly email: string;

  @IsString()
  @Matches(/^[A-Za-z\d!@#$%^&*()]{8,30}$/)
  readonly password: string;
}
```

데코레이터는 타입스크립트 스펙에서 아직 실험적인 기능입니다. tsconfig.json파일을 보겠습니다.  tsconfig.json 파일은 타입스크립트의 빌드 환경을 정의한 파일입니다.

```json
{
  "compilerOptions": {
        ...
    "experimentalDecorators": true,
        ...
  }
}
```

`experimentalDecorators`옵션이 true로 되어있어야 데코레이터를 사용할 수 있습니다. 데코레이터는 실험적인 기능이긴 하지만 안정적이며 많은 프로젝트에서 사용하고 있습니다.  

데코레이터는 위처럼 `@expression`과 같은 형식으로 사용합니다. 여기서 expression은 데코레이팅된 선언에 대한 정보와 함께 런타임에 호출되는 함수여야합니다. 

다음과 같은 메서드 데코레이터가 있고 이 데코레이터를 test라는 메서드에 선언합니다.
```typescript
function deco(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
  console.log('데코레이터가 평가됨');
}

class TestClass {
  @deco
  test() {
    console.log('함수 호출됨')
  }
}

const t = new TestClass();
t.test();
```
여기서 deco함수에 인자들이 있는데 메서드 데코레이터로 사용하기 위해서는 이렇게 정의해야 합니다.

이제 TestClass를 생성하고 test메서드를 호출하면 다음과 같은 결과가 콘솔에 출력됩니다.
```
데코레이터가 평가됨
함수 호출됨
```
만약 데코레이터에 인자를 넘겨서 데코레이터의 동작을 변경하고 싶다면 데코레이터 팩토리(데코레이터를 리턴하는 함수)를 만들면 됩니다. 위의 예시를 다음과 같이 value라는 인자를 받도록 바꿔보겠습니다.

```typescript
function deco(value: string) {
  console.log('데코레이터가 평가됨');
  return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    console.log(value);
  }
}

class TestClass {
  @deco('HELLO')
  test() {
    console.log('함수 호출됨')
  }
}
```
결과는 다음과 같습니다
```
데코레이터가 평가됨
HELLO
함수 호출됨
```

## 데코레이터 합성
만약 여러 데코레이터를 사용할 때 다음 단계가 수행됩니다.
1. 각 데코레이터의 표현은 위에서 아래로 **평가(evaluate)**됩니다.
2. 그런 다음 결과는 아래에서 위로 함수로 **호출(call)**됩니다.

다음 예시는 합성순서에 따른 결과가 어떻게 달라지는지 보여줍니다.

```typescript
function first() {
  console.log("first(): factory evaluated");
  return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    console.log("first(): called");
  };
}

function second() {
  console.log("second(): factory evaluated");
  return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    console.log("second(): called");
  };
}

class ExampleClass {
  @first()
  @second()
  method() {
        console.log('method is called');
    }
}
```
```
first(): factory evaluated
second(): factory evaluated
second(): called
first(): called
method is called
```
이제 타입스크립트가 지원하는 5가지 데코레이터를 알아봅시다.

## 클래스 데코레이터(Class Decorator)
클래스 데코레이터는 클래스의 생성자에 적용되어 클래스 정의(definition)을 읽거나 수정할 수 있습니다. [선언파일](#1)과 선언 클래스(declare class)내에서는 사용할 수 없습니다.

다음 코드는 클래스에 `reportingURL` 속성을 추가하는 클래스 데코레이터의 예입니다.  
```typescript
function reportableClassDecorator<T extends { new (...args: any[]): {} }>(constructor: T) {
  return class extends constructor {
    reportingURL = "http://www.example.com";
  };
}

@reportableClassDecorator
class BugReport {
  type = "report";
  title: string;

  constructor(t: string) {
    this.title = t;
  }
}

const bug = new BugReport("Needs dark mode");
console.log(bug);
```
- L1: 클래스 데코레이터 팩토리입니다. 생성자 타입(`new (...args: any[]): {}`. new 키워드와 함께 어떠한 형식의 인자들도 받을 수 있는 타입)을 상속받는 제네릭 타입 `T` 를 가지는 생성자(`constructor`)를 팩토리 메서스의 인자로 전달하고 있습니다.

- L2: 클래스 데코레이터는 생성자를 리턴하는 함수여야 합니다.

- L3: 클래스 데코레이터가 적용되는 클래스에 새로운 reportingURL이라는 새로운 속성을 추가합니다.

위 코드의 출력결과는 다음과 같습니다.

```
{
	type: 'report',
	title: 'Needs dark mode',
	reportingURL: 'http://www.example.com'
}
```

BugReport 클래스에 선언되어있지 않은 새로운 속성이 추가되었습니다.
> 클래스 타입이 변경되는 것은 아닙니다. 타입 시스템은 reportingURL을 인식하지 못하기 때문에 `bug.reportingURL`과 같이 직접 사용할 수 없습니다.

## 메서드 데코레이터 (Method Decorator)
