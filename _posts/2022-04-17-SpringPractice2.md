---
title: 도메인 분석 설계
description:
categories:
 - spring-practice
tags:
---

# 도메인 분석 설계

## 요구사항 분석

<img alt="요구사항" src="/assets/images/helloshop.png" />  

**기능 목록**

- 회원 기능
  - 회원 등록
  - 회원 조회
- 상품 기능
  - 상품 등록
  - 상품 수정
  - 상품 조회
- 주문 기능
  - 상품 주문
  - 주문 내역 조회
  - 주문 취소
- 기타 요구사항
  - 상품은 재고 관리가 필요하다.
  - 상품의 종류는 도서, 음반, 영화가 있다.
  - 상품을 카테고리로 구분할 수 있다.
  - 상품 주문시 배송 정보를 입력할 수 있다.

## 도메인 모델과 테이블 설계

<img title="" src="/assets/images/domain.png" alt="도메인">  

**회원, 주문, 상품의 관계**: 회원은 여러 상품을 주문할 수 있다. 그리고 한 번 주문할 때 여러 상품을 선택할 수 있으므te 주문과 상품은 다대다 관계다. 하지만 이런 다대다 관계는 관계형 데이터베이스는 물론이고 엔티티에서도 거의 사용하지 않는다. 따라서 그림처럼 주문상품이라는 엔티티를 추가해서 다대다 관계를 일대다, 다대일 관계로 풀어냈다.  

**상품 분류**: 상품은 도서, 음반, 영화로 구분되는데 상품이라는 공통 속성을 사용하므로 상속 구조로 표현했다.  

<img alt="테이블" src="/assets/images/entity.png" />  

1. **회원(Member)**: 이름과 임베디드 타입인 주소(Address), 주문(orders) 리스트를 가진다.  
2. **주문(Order)**: 한 번 주문시 여러 상품을 주문할 수 있으므로 주문과 주문상품( OrderItem )은 일대다 관계다. 주문은 상품을 주문한 회원과 배송 정보, 주문 날짜, 주문 상태( status )를 가지고 있다. 주문 상태는 열거형을 사용했는데 주문(ORDER), 취소(CANCEL)을 표현할 수 있다.  
3. **주문상품(OrderItem)**: 주문한 상품 정보와 주문 금액(orderPrice), 주문 수량(count) 정보를 가지고 있다. (보통 OrderLine , LineItem 으로 많이 표현한다.)  
4. **상품(Item)**: 이름, 가격, 재고수량(stockQuantity)을 가지고 있다. 상품을 주문하면 재고수량이 줄어든다. 상품의 종류로는 도서, 음반, 영화가 있는데 각각은 사용하는 속성이 조금씩 다르다.  
5. **배송(Delivery)**: 주문시 하나의 배송 정보를 생성한다. 주문과 배송은 일대일 관계다.  
6. **카테고리(Category)**: 상품과 다대다 관계를 맺는다. parent , child 로 부모, 자식 카테고리를 연결한다.  
7. **주소(Address)**: 값 타입(임베디드 타입)이다. 회원과 배송(Delivery)에서 사용한다.  

> 실무에서는 엔티티를 위와 같이 짜면 안된다. 양방향보다는 단방향을 지향하고, 다대다 관계는 지양해야 한다. 

## 회원 테이블 분석

<img alt="회원테이블" src="/assets/images/member-table.png" />

- **MEMBER**: 회원 엔티티의 `Address`임베디드 타입 정보가 회원 테이블에 그대로 들어갔다. `DELIVERY` 테이블도 마찬가지다.

- **ITEM**: 앨범, 도서, 영화 타입을 통합해서 하나의 테이블로 만들었다 `DTYPE` 컬럼으로 타입으,ㄹ 구분한다.

> 데이터베이스에서 order는 예약어인 경우가 많아 관례상 orders로 작성한다.

> 실제 코드에서는 DB에 소문자_언더스코어 스타일을 사용한다. 데이터베이스 테이블명, 컬럼명에 대한 관례는 회사마다 다르며 보통은 대문자+\_(언더스코어) 또는 소문자+\_(언더스코어) 방식 중 하나를 사용한다.

## 연관관계 매핑 분석

**회원과 주문**: 일대다, 다대일의 양방향 관계다. 외래키가 있는 주문을 연관관계의 주인으로 한다.

**주문상품과 주문**: 다대일 양방향 관계다. 외래 키가 주문상품에 있으므로 주문상품이 연관관계의 주인이다. 그러므로 `OrderItem.order` 를 `ORDER_ITEM.ORDER_ID` 외래 키와 매핑한다.

**주문상품과 상품**: 다대일 단방향 관계다. `OrderItem.item` 을 `ORDER_ITEM.ITEM_ID` 외래 키와 매핑한다.

**주문과 배송**: 일대일 양방향 관계다. Order.delivery 를 ORDERS.DELIVERY_ID 외래 키와 매핑한다.

**카테고리와 상품**: : `@ManyToMany` 를 사용해서 매핑한다.(실무에서 @ManyToMany는 사용하지 말자. 여기서는 다대다 관계를 예제로 보여주기 위해 추가했을 뿐이다)

> **참고: 외래 키가 있는 곳을 연관관계의 주인으로 정해라.**
> 
> 연관관계의 주인은 단순히 외래 키를 누가 관리하냐의 문제이지 비즈니스상 우위에 있다고 주인으로 정하면 안된다.

## 엔티티 클래스 개발

- 예제에서는 설명을 쉽게하기 위해 엔티티 클래스에 Getter, Setter를 모두 열고, 최대한 단순하게 설계

- 실무에서는 가급적 Getter는 열어두고, Setter는 꼭 필요한 경우에만 사용하는 것을 추천

- [GitHub](https://github.com/EomYoosang/SpringPractice/tree/main/src/main/java/jpabook/jpashop/domain)
  
  - 엔티티의 식별자는 `id`를 사용하고 PK컬럼명은 `테이블명_id`를 사용한다. 
  
  - 카테고리와 아이템에서 다대다 관계를 사용하였지만 실무에서는 사용하지 않는다.
    
    - `@ManyToMany`는 중간 엔티티(`CategoryItem`)를 만들고 다대일, 일대다 관계로 풀어낸다. 하지만 중간 엔티티에 컬럼을 추가할 수 없어 실제 사용하기엔 어려움이 있다.
  
  - 값 타입은 변경 불가능하게 해야한다. `@Setter`를 제거하고 생성자에서 값을 모두 초기화해서 변경 불가능한 클래스를 만든다. JPA스펙상 엔티티나 임베디드 타입은 자바 기본 생성자를 `public`이나 `protected`로 설정해야 한다. `protected`가 더 안전하다.
    JPA가 이런 제약을 두는 이유는 객체를 생성할 때 리플렉션 등의 기술을 사용할 수 있도록 하기 위함이다.  

## 엔티티 설계시 유의점

- 엔티티에는 가급적 `Setter`를 열지 말자

- 모든 연관관계는 지연로딩으로 설정
  
  - 즉시로딩(`EAGER`)은 예측하기 어렵고, 어떤 SQL이 실행될지 추적하기 어렵다. 특히 JPQL을  실행할 때 N+1문제가 자주 발생한다. 
  
  - 모든 연관관계는 지연로딩(`LAZY`)으로 설정한다.
  
  - 연관된 엔티티를 조회해야 한다면 fetch join 또는 엔티티 그래프 기능을 이용한다. 
  
  - @OneToOne 또는 @ManyToOne관계는 기본이 즉시로딩이므로 지연로딩으로 설정해야 한다.

- 컬렉션은 필드에서 초기화한다. 
  
  - `null`문제에서 안전하다.
  
  - 하이버네이트는 엔티티를 영속화 할 때, 컬랙션을 감싸서 하이버네이트가 제공하는 내장 컬렉션으로 변경한다. 만약 getOrders() 처럼 임의의 메서드에서 컬력션을 잘못 생성하면 하이버네이트 내부 메커니즘에 문제가 발생할 수 있다. 따라서 필드레벨에서 생성하는 것이 가장 안전하고, 코드도 간결하다.

- 테이블, 컬럼명 생성 전략
  
  - 하이버네이트 기존 구현: 엔티티의 필드명을 그대로 테이블 명으로 사용
    
    (`SpringPhysicalNamingStrategy`)
  
  - 스프링 부트 신규 설정(엔티티(필드) -> 테이블(컬럼))
    
    1. 카멜 케이스 -> 언더스코어(memberPoint -> member_point)
    
    2. .(점) -> _(언더스코어)
    
    3. 대문자 -> 소문자
  
  - 